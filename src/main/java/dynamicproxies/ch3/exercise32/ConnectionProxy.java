/*
 * This class forms part of the Dynamic Proxies in Java Course by
 * Dr Heinz Max Kabutz from JavaSpecialists.eu and may not be distributed
 * without written consent.
 *
 * Copyright 2020, Dr Heinz Max Kabutz, All rights reserved.
 */

package dynamicproxies.ch3.exercise32;

import dynamicproxies.util.measurement.*;

import java.sql.*;
import java.util.*;
import java.util.concurrent.*;

// TODO: Delete and replace with dynamic proxy
public class ConnectionProxy implements Connection {
  private final Connection connection;
  private final TimeMeasuringHandler handler;

  public ConnectionProxy(Connection connection, TimeMeasuringHandler handler) {
    this.connection = connection;
    this.handler = handler;
  }

  @Override
  public Statement createStatement() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createStatement")) {
      return new StatementProxy(connection.createStatement(), handler);
    }
  }
  @Override
  public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createStatement", resultSetType, resultSetConcurrency)) {
      return new StatementProxy(connection.createStatement(resultSetType, resultSetConcurrency), handler);
    }
  }
  @Override
  public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createStatement", resultSetType, resultSetConcurrency,
        resultSetHoldability)) {
      return new StatementProxy(connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
          , handler);
    }
  }
  @Override
  public PreparedStatement prepareStatement(String sql) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareStatement", sql)) {
      return new PreparedStatementProxy(connection.prepareStatement(sql), handler);
    }
  }
  @Override
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareStatement", sql, resultSetType,
        resultSetConcurrency)) {
      return new PreparedStatementProxy(connection.prepareStatement(sql, resultSetType, resultSetConcurrency), handler);
    }
  }
  @Override
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
                                            int resultSetHoldability) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareStatement", sql, resultSetType,
        resultSetConcurrency, resultSetHoldability)) {
      return new PreparedStatementProxy(connection.prepareStatement(sql, resultSetType, resultSetConcurrency,
          resultSetHoldability), handler);
    }
  }
  @Override
  public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareStatement", sql, autoGeneratedKeys)) {
      return new PreparedStatementProxy(connection.prepareStatement(sql, autoGeneratedKeys), handler);
    }
  }
  @Override
  public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareStatement", sql, columnIndexes)) {
      return new PreparedStatementProxy(connection.prepareStatement(sql, columnIndexes), handler);
    }
  }
  @Override
  public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareStatement", sql, columnNames)) {
      return new PreparedStatementProxy(connection.prepareStatement(sql, columnNames), handler);
    }
  }
  @Override
  public void close() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "close")) {
      connection.close();
    }
  }

  @Override
  public CallableStatement prepareCall(String sql) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareCall", sql)) {
      return connection.prepareCall(sql);
    }
  }
  @Override
  public String nativeSQL(String sql) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "nativeSQL", sql)) {
      return connection.nativeSQL(sql);
    }
  }
  @Override
  public void setAutoCommit(boolean autoCommit) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setAutoCommit", autoCommit)) {
      connection.setAutoCommit(autoCommit);
    }
  }
  @Override
  public boolean getAutoCommit() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getAutoCommit")) {
      return connection.getAutoCommit();
    }
  }
  @Override
  public void commit() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "commit")) {
      connection.commit();
    }
  }
  @Override
  public void rollback() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "rollback")) {
      connection.rollback();
    }
  }
  @Override
  public boolean isClosed() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "isClosed")) {
      return connection.isClosed();
    }
  }
  @Override
  public DatabaseMetaData getMetaData() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getMetaData")) {
      return connection.getMetaData();
    }
  }
  @Override
  public void setReadOnly(boolean readOnly) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setReadOnly", readOnly)) {
      connection.setReadOnly(readOnly);
    }
  }
  @Override
  public boolean isReadOnly() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "isReadOnly")) {
      return connection.isReadOnly();
    }
  }
  @Override
  public void setCatalog(String catalog) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setCatalog", catalog)) {
      connection.setCatalog(catalog);
    }
  }
  @Override
  public String getCatalog() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getCatalog")) {
      return connection.getCatalog();
    }
  }
  @Override
  public void setTransactionIsolation(int level) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setTransactionIsolation", level)) {
      connection.setTransactionIsolation(level);
    }
  }
  @Override
  public int getTransactionIsolation() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getTransactionIsolation")) {
      return connection.getTransactionIsolation();
    }
  }
  @Override
  public SQLWarning getWarnings() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getWarnings")) {
      return connection.getWarnings();
    }
  }
  @Override
  public void clearWarnings() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "clearWarnings")) {
      connection.clearWarnings();
    }
  }
  @Override
  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareCall", sql, resultSetType, resultSetConcurrency)) {
      return connection.prepareCall(sql, resultSetType, resultSetConcurrency);
    }
  }
  @Override
  public Map<String, Class<?>> getTypeMap() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getTypeMap")) {
      return connection.getTypeMap();
    }
  }
  @Override
  public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setTypeMap", map)) {
      connection.setTypeMap(map);
    }
  }
  @Override
  public void setHoldability(int holdability) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setHoldability", holdability)) {
      connection.setHoldability(holdability);
    }
  }
  @Override
  public int getHoldability() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getHoldability")) {
      return connection.getHoldability();
    }
  }
  @Override
  public Savepoint setSavepoint() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setSavepoint")) {
      return connection.setSavepoint();
    }
  }
  @Override
  public Savepoint setSavepoint(String name) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setSavepoint", name)) {
      return connection.setSavepoint(name);
    }
  }
  @Override
  public void rollback(Savepoint savepoint) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "rollback", savepoint)) {
      connection.rollback(savepoint);
    }
  }
  @Override
  public void releaseSavepoint(Savepoint savepoint) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "releaseSavepoint", savepoint)) {
      connection.releaseSavepoint(savepoint);
    }
  }
  @Override
  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
                                       int resultSetHoldability) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "prepareCall", sql, resultSetType, resultSetConcurrency,
        resultSetHoldability)) {
      return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }
  }
  @Override
  public Clob createClob() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createClob")) {
      return connection.createClob();
    }
  }
  @Override
  public Blob createBlob() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createBlob")) {
      return connection.createBlob();
    }
  }
  @Override
  public NClob createNClob() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createNClob")) {
      return connection.createNClob();
    }
  }
  @Override
  public SQLXML createSQLXML() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createSQLXML")) {
      return connection.createSQLXML();
    }
  }
  @Override
  public boolean isValid(int timeout) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "isValid", timeout)) {
      return connection.isValid(timeout);
    }
  }
  @Override
  public void setClientInfo(String name,
                            String value) throws SQLClientInfoException {
    try (var measurer = handler.start("java.sql.Connection", "setClientInfo", name, value)) {
      connection.setClientInfo(name, value);
    }
  }
  @Override
  public void setClientInfo(
      Properties properties) throws SQLClientInfoException {
    try (var measurer = handler.start("java.sql.Connection", "setClientInfo", properties)) {
      connection.setClientInfo(properties);
    }
  }
  @Override
  public String getClientInfo(String name) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getClientInfo", name)) {
      return connection.getClientInfo(name);
    }
  }
  @Override
  public Properties getClientInfo() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getClientInfo")) {
      return connection.getClientInfo();
    }
  }
  @Override
  public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createArrayOf", typeName, elements)) {
      return connection.createArrayOf(typeName, elements);
    }
  }
  @Override
  public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "createStruct", typeName, attributes)) {
      return connection.createStruct(typeName, attributes);
    }
  }
  @Override
  public void setSchema(String schema) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setSchema", schema)) {
      connection.setSchema(schema);
    }
  }
  @Override
  public String getSchema() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getSchema")) {
      return connection.getSchema();
    }
  }
  @Override
  public void abort(Executor executor) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "abort", executor)) {
      connection.abort(executor);
    }
  }
  @Override
  public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setNetworkTimeout", executor, milliseconds)) {
      connection.setNetworkTimeout(executor, milliseconds);
    }
  }
  @Override
  public int getNetworkTimeout() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "getNetworkTimeout")) {
      return connection.getNetworkTimeout();
    }
  }
  @Override
  public void beginRequest() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "beginRequest")) {
      connection.beginRequest();
    }
  }
  @Override
  public void endRequest() throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "endRequest")) {
      connection.endRequest();
    }
  }
  @Override
  public boolean setShardingKeyIfValid(ShardingKey shardingKey, ShardingKey superShardingKey, int timeout) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setShardingKeyIfValid", shardingKey, superShardingKey,
        timeout)) {
      return connection.setShardingKeyIfValid(shardingKey, superShardingKey, timeout);
    }
  }
  @Override
  public boolean setShardingKeyIfValid(ShardingKey shardingKey, int timeout) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setShardingKeyIfValid", shardingKey, timeout)) {
      return connection.setShardingKeyIfValid(shardingKey, timeout);
    }
  }
  @Override
  public void setShardingKey(ShardingKey shardingKey, ShardingKey superShardingKey) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setShardingKey", shardingKey, superShardingKey)) {
      connection.setShardingKey(shardingKey, superShardingKey);
    }
  }
  @Override
  public void setShardingKey(ShardingKey shardingKey) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "setShardingKey", shardingKey)) {
      connection.setShardingKey(shardingKey);
    }
  }
  @Override
  public <T> T unwrap(Class<T> iface) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "unwrap", iface)) {
      return connection.unwrap(iface);
    }
  }
  @Override
  public boolean isWrapperFor(Class<?> iface) throws SQLException {
    try (var measurer = handler.start("java.sql.Connection", "isWrapperFor", iface)) {
      return connection.isWrapperFor(iface);
    }
  }
}